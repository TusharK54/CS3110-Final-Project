(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    var
     global_data=runtime.caml_get_global_data(),
     pos$3=caml_new_string("src/splittable_random.ml:333:41"),
     pos$2=caml_new_string("src/splittable_random.ml:319:41"),
     pos$1=caml_new_string("src/splittable_random.ml:299:41"),
     cst_src_splittable_random_ml$5=
      caml_new_string("src/splittable_random.ml"),
     cst_bits_to_represent=caml_new_string(": bits_to_represent"),
     cst_src_splittable_random_ml$6=
      caml_new_string("src/splittable_random.ml"),
     cst_min_represented_by_n_bits=
      caml_new_string(": min_represented_by_n_bits"),
     cst_src_splittable_random_ml$7=
      caml_new_string("src/splittable_random.ml"),
     cst_max_represented_by_n_bits=
      caml_new_string(": max_represented_by_n_bits"),
     int64$0=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_float_bounds_are_not_finite_numbers=
      caml_new_string("float: bounds are not finite numbers"),
     cst_float_bounds_are_crossed=caml_new_string("float: bounds are crossed"),
     cst_int64_crossed_bounds=caml_new_string("int64: crossed bounds"),
     pos=caml_new_string("src/splittable_random.ml:144:19"),
     pos$0=caml_new_string("src/splittable_random.ml:138:19"),
     draw_maximum=runtime.caml_int64_create_lo_mi_hi(104,0,0),
     remainder_maximum=runtime.caml_int64_create_lo_mi_hi(9,0,0),
     cst_gamma_value_is_not_odd=caml_new_string("gamma value is not odd"),
     cst_splittable_random=caml_new_string("splittable_random"),
     cst=caml_new_string(""),
     cst_splittable_random$0=caml_new_string("splittable_random"),
     golden_gamma=runtime.caml_int64_create_lo_mi_hi(4881429,7977343,40503),
     cst_src_splittable_random_ml=caml_new_string("src/splittable_random.ml"),
     cst_odd_gamma=caml_new_string(": odd gamma"),
     cst_src_splittable_random_ml$0=
      caml_new_string("src/splittable_random.ml"),
     cst_remainder_is_unbiased=caml_new_string(": remainder_is_unbiased"),
     cst_src_splittable_random_ml$1=
      caml_new_string("src/splittable_random.ml"),
     cst_double_ulp=caml_new_string(": double_ulp"),
     cst_src_splittable_random_ml$2=
      caml_new_string("src/splittable_random.ml"),
     cst_unit_float_from_int64=caml_new_string(": unit_float_from_int64"),
     cst_src_splittable_random_ml$3=
      caml_new_string("src/splittable_random.ml"),
     cst_src_splittable_random_ml$4=
      caml_new_string("src/splittable_random.ml"),
     cst_let_int64_1L_in_fun_unit_float_from_int64_int64=
      caml_new_string
       ("let int64 = 1L in fun () -> unit_float_from_int64 int64"),
     cst_unit_float_from_int64$0=caml_new_string("unit_float_from_int64"),
     cst_splittable_random$1=caml_new_string("splittable_random"),
     Ppx_assert_lib_Runtime=global_data.Ppx_assert_lib__Runtime,
     Base_Int=global_data.Base__Int,
     Base=global_data.Base,
     Assert_failure=global_data.Assert_failure,
     Inline_test_config=global_data.Inline_test_config,
     Ppx_inline_test_lib_Runtime=global_data.Ppx_inline_test_lib__Runtime,
     Base_Float=global_data.Base__Float,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Base_Int64=global_data.Base__Int64,
     Base_Word_size=global_data.Base__Word_size,
     Base_Int63=global_data.Base__Int63,
     Base_Error=global_data.Base__Error,
     Base_Random=global_data.Base__Random,
     Ppx_bench_lib_Benchmark_accumulator=
      global_data.Ppx_bench_lib__Benchmark_accumulator,
     Base_Int32=global_data.Base__Int32,
     Base_Nativeint=global_data.Base__Nativeint;
    caml_call1
     (Ppx_bench_lib_Benchmark_accumulator[1][1],cst_splittable_random);
    caml_call2(Ppx_inline_test_lib_Runtime[2],cst_splittable_random$0,cst);
    var
     _F_=[0,caml_new_string("src/splittable_random.ml"),289,6],
     _B_=[0,caml_new_string("hi")],
     _C_=[0,caml_new_string("lo")],
     _D_=[0,caml_new_string("hi")],
     _E_=[0,caml_new_string("lo")],
     _v_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _A_=[0,caml_new_string("src/splittable_random.ml"),226,2],
     _w_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _z_=[0,caml_new_string("src/splittable_random.ml"),227,2],
     _x_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _y_=[0,caml_new_string("src/splittable_random.ml"),228,2],
     _t_=[0,caml_new_string("src/splittable_random.ml"),213,4],
     _s_=[0,caml_new_string("src/splittable_random.ml"),214,4],
     _r_=[0,caml_new_string("src/splittable_random.ml"),218,4],
     _q_=[0,caml_new_string("src/splittable_random.ml"),219,4],
     _m_=[0,caml_new_string("hi")],
     _n_=[0,caml_new_string("lo")],
     _o_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _j_=[0,caml_new_string("output")],
     _k_=[0,caml_new_string("input")],
     _g_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _h_=runtime.caml_int64_create_lo_mi_hi(11184810,11184810,43690),
     _e_=runtime.caml_int64_create_lo_mi_hi(15001017,4680988,48984),
     _f_=runtime.caml_int64_create_lo_mi_hi(3215851,4832019,38096),
     _c_=runtime.caml_int64_create_lo_mi_hi(5606605,11524077,65361),
     _d_=runtime.caml_int64_create_lo_mi_hi(8776787,12189210,50382),
     _a_=runtime.caml_int64_create_lo_mi_hi(1,0,0);
    function is_odd(x)
     {var _aR_=caml_call2(Base_Int64[97][20],x,_a_);
      return caml_call2(Base_Int64[97][9],_aR_,x)}
    var _b_=Base_Int64[75];
    function of_int(seed)
     {return [0,caml_call1(Base_Int64[98],seed),golden_gamma]}
    function copy(param)
     {var seed=param[1],odd_gamma=param[2];return [0,seed,odd_gamma]}
    function mix_bits(z,n)
     {var _aQ_=caml_call2(Base_Int64[97][25],z,n);
      return caml_call2(Base_Int64[97][21],z,_aQ_)}
    function mix64(z)
     {var
       _aO_=mix_bits(z,33),
       z$0=caml_call2(Base_Int64[97][3],_aO_,_c_),
       _aP_=mix_bits(z$0,33),
       z$1=caml_call2(Base_Int64[97][3],_aP_,_d_);
      return mix_bits(z$1,33)}
    function mix_odd_gamma(z$1)
     {var
       _aK_=mix_bits(z$1,30),
       z=caml_call2(Base_Int64[97][3],_aK_,_e_),
       _aL_=mix_bits(z,27),
       z$0=caml_call2(Base_Int64[97][3],_aL_,_f_),
       _aM_=mix_bits(z$0,31),
       z$2=caml_call2(Base_Int64[97][20],_aM_,_g_),
       _aN_=caml_call2(Base_Int64[97][25],z$2,1),
       n=caml_call1(_b_,caml_call2(Base_Int64[97][21],z$2,_aN_));
      return caml_call2(Base_Int[15],n,24)
              ?caml_call2(Base_Int64[97][21],z$2,_h_)
              :z$2}
    function _i_(param)
     {var input=-1000000;
      for(;;)
       {var output=mix_odd_gamma(caml_call1(Base_Int64[98],input));
        if(1 - is_odd(output))
         {var
           _aG_=[0,[1,[0,_j_,[0,caml_call1(Base[127],output),0]]],0],
           _aH_=[0,[1,[0,_k_,[0,caml_call1(Base[115],input),0]]],_aG_],
           _aI_=
            [1,
             [0,
              caml_call1(Sexplib0_Sexp_conv[7],cst_gamma_value_is_not_odd),
              _aH_]];
          caml_call1(Base_Error[27],_aI_)}
        var _aJ_=input + 1 | 0;
        if(1000000 !== input){var input=_aJ_;continue}
        return 0}}
    caml_call8
     (Ppx_inline_test_lib_Runtime[5],
      Inline_test_config,
      cst_odd_gamma,
      0,
      cst_src_splittable_random_ml,
      72,
      2,
      296,
      _i_);
    function next_seed(t)
     {var next=caml_call2(Base_Int64[97][1],t[1],t[2]);
      t[1] = next;
      return next}
    function of_seed_and_gamma(seed,gamma)
     {var seed$0=mix64(seed),odd_gamma=mix_odd_gamma(gamma);
      return [0,seed$0,odd_gamma]}
    function random_int64(random_state)
     {return caml_call3
              (Base_Random[18][14],random_state,Base_Int64[89],Base_Int64[88])}
    function create(random_state)
     {var seed=random_int64(random_state),gamma=random_int64(random_state);
      return of_seed_and_gamma(seed,gamma)}
    function split(t)
     {var seed=next_seed(t),gamma=next_seed(t);
      return of_seed_and_gamma(seed,gamma)}
    function next_int64(t){return mix64(next_seed(t))}
    function perturb(t,salt)
     {var
       _aF_=mix64(caml_call1(Base_Int64[98],salt)),
       next=caml_call2(Base_Int64[97][1],t[1],_aF_);
      t[1] = next;
      return 0}
    function bool(state){return is_odd(next_int64(state))}
    function remainder_is_unbiased
     (draw,remainder,draw_maximum,remainder_maximum)
     {var
       _aD_=caml_call2(Base_Int64[97][2],draw_maximum,remainder_maximum),
       _aE_=caml_call2(Base_Int64[97][2],draw,remainder);
      return caml_call2(Base_Int64[97][8],_aE_,_aD_)}
    function _l_(param)
     {function is_unbiased(draw)
       {var
         _aC_=caml_call1(Base_Int64[68],remainder_maximum),
         remainder=caml_call2(Base_Int64[54],draw,_aC_);
        return remainder_is_unbiased
                (draw,remainder,draw_maximum,remainder_maximum)}
      var i$0=0;
      for(;;)
       {var
         got$0=is_unbiased(caml_call1(Base_Int64[98],i$0)),
         message$0=[0,caml_call1(Base_Int[10],i$0)],
         sexpifier$0=Base[96],
         comparator$0=Base[91];
        caml_call8
         (Ppx_assert_lib_Runtime[3],
          pos$0,
          sexpifier$0,
          comparator$0,
          0,
          message$0,
          0,
          1,
          got$0);
        var _aB_=i$0 + 1 | 0;
        if(99 !== i$0){var i$0=_aB_;continue}
        var i=100;
        for(;;)
         {var
           got=is_unbiased(caml_call1(Base_Int64[98],i)),
           message=[0,caml_call1(Base_Int[10],i)],
           sexpifier=Base[96],
           comparator=Base[91];
          caml_call8
           (Ppx_assert_lib_Runtime[3],
            pos,
            sexpifier,
            comparator,
            0,
            message,
            0,
            0,
            got);
          var _aA_=i + 1 | 0;
          if(104 !== i){var i=_aA_;continue}
          return 0}}}
    caml_call8
     (Ppx_inline_test_lib_Runtime[5],
      Inline_test_config,
      cst_remainder_is_unbiased,
      0,
      cst_src_splittable_random_ml$0,
      129,
      0,
      633,
      _l_);
    function int64(state,lo,hi)
     {if(caml_call2(Base_Int64[97][10],lo,hi))
       {var
         _au_=[0,[1,[0,_m_,[0,caml_call1(Base[127],hi),0]]],0],
         _av_=[0,[1,[0,_n_,[0,caml_call1(Base[127],lo),0]]],_au_],
         _aw_=
          [1,
           [0,caml_call1(Sexplib0_Sexp_conv[7],cst_int64_crossed_bounds),_av_]];
        caml_call1(Base_Error[27],_aw_)}
      var maximum=caml_call2(Base_Int64[97][2],hi,lo);
      if(caml_call2(Base_Int64[97][9],maximum,Base_Int64[88]))
       {var
         _ax_=Base_Int64[88],
         _ay_=next_int64(state),
         _az_=caml_call2(Base_Int64[97][19],_ay_,_ax_);
        return caml_call2(Base_Int64[97][1],_az_,lo)}
      if(caml_call2(Base_Int64[97][7],maximum,_o_))
       for(;;)
        {var
          _ar_=Base_Int64[88],
          _as_=next_int64(state),
          draw$0=caml_call2(Base_Int64[97][19],_as_,_ar_),
          _at_=caml_call1(Base_Int64[68],maximum),
          remainder=caml_call2(Base_Int64[54],draw$0,_at_);
         if(remainder_is_unbiased(draw$0,remainder,Base_Int64[88],maximum))
          return caml_call2(Base_Int64[97][1],remainder,lo);
         continue}
      for(;;)
       {var draw=next_int64(state);
        if(caml_call2(Base_Int64[97][8],lo,draw))
         if(caml_call2(Base_Int64[97][8],draw,hi))return draw;
        continue}}
    function int$0(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int64[98],lo),
       hi$0=caml_call1(Base_Int64[98],hi),
       _aq_=int64(state,lo$0,hi$0);
      return caml_call1(Base_Int64[105],_aq_)}
    function int32(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int64[100],lo),
       hi$0=caml_call1(Base_Int64[100],hi),
       _ap_=int64(state,lo$0,hi$0);
      return caml_call1(Base_Int64[106],_ap_)}
    function nativeint(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int64[102],lo),
       hi$0=caml_call1(Base_Int64[102],hi),
       _ao_=int64(state,lo$0,hi$0);
      return caml_call1(Base_Int64[107],_ao_)}
    function int63(state,lo,hi)
     {var
       lo$0=caml_call1(Base_Int63[83],lo),
       hi$0=caml_call1(Base_Int63[83],hi),
       _an_=int64(state,lo$0,hi$0);
      return caml_call1(Base_Int63[107],_an_)}
    var double_ulp=caml_call2(Base[200],2.,-53.);
    function _p_(param)
     {if(0 === Base_Word_size[3])
       {var _ah_=caml_call2(Base[197],1.,double_ulp);
        if(caml_call2(Base_Float[103][11],_ah_,1.))
         {var
           _ai_=caml_call2(Base[199],double_ulp,2.),
           _aj_=caml_call2(Base[197],1.,_ai_);
          if(caml_call2(Base_Float[103][8],_aj_,1.))return 0;
          throw [0,Assert_failure,_q_]}
        throw [0,Assert_failure,_r_]}
      var _ak_=caml_call2(Base[197],1.,double_ulp);
      if(caml_call2(Base_Float[103][11],_ak_,1.))
       {var
         _al_=caml_call2(Base[199],double_ulp,2.),
         _am_=caml_call2(Base[197],1.,_al_);
        if(caml_call2(Base_Float[103][9],_am_,1.))return 0;
        throw [0,Assert_failure,_s_]}
      throw [0,Assert_failure,_t_]}
    caml_call8
     (Ppx_inline_test_lib_Runtime[5],
      Inline_test_config,
      cst_double_ulp,
      0,
      cst_src_splittable_random_ml$1,
      209,
      0,
      457,
      _p_);
    function unit_float_from_int64(int64)
     {var
       _af_=caml_call2(Base_Int64[97][25],int64,11),
       _ag_=caml_call1(Base_Int64[2],_af_);
      return caml_call2(Base[198],_ag_,double_ulp)}
    function _u_(param)
     {var _ab_=unit_float_from_int64(_v_);
      if(caml_call2(Base_Float[103][9],_ab_,0.))
       {var _ac_=unit_float_from_int64(_w_);
        if(caml_call2(Base_Float[103][11],_ac_,1.))
         {var
           _ad_=caml_call2(Base[197],1.,double_ulp),
           _ae_=unit_float_from_int64(_x_);
          if(caml_call2(Base_Float[103][9],_ae_,_ad_))return 0;
          throw [0,Assert_failure,_y_]}
        throw [0,Assert_failure,_z_]}
      throw [0,Assert_failure,_A_]}
    caml_call8
     (Ppx_inline_test_lib_Runtime[5],
      Inline_test_config,
      cst_unit_float_from_int64,
      0,
      cst_src_splittable_random_ml$2,
      224,
      0,
      275,
      _u_);
    function unit_float(state)
     {return unit_float_from_int64(next_int64(state))}
    function float$0(state,lo$1,hi$0)
     {var
       _V_=caml_call1(Base_Float[115],lo$1),
       _W_=_V_?caml_call1(Base_Float[115],hi$0):_V_;
      if(1 - _W_)
       {var
         _X_=[0,[1,[0,_B_,[0,caml_call1(Base[109],hi$0),0]]],0],
         _Y_=[0,[1,[0,_C_,[0,caml_call1(Base[109],lo$1),0]]],_X_],
         _Z_=
          [1,
           [0,
            caml_call1
             (Sexplib0_Sexp_conv[7],cst_float_bounds_are_not_finite_numbers),
            _Y_]];
        caml_call1(Base[207],_Z_)}
      if(caml_call2(Base_Float[11],lo$1,hi$0))
       {var
         ___=[0,[1,[0,_D_,[0,caml_call1(Base[109],hi$0),0]]],0],
         _$_=[0,[1,[0,_E_,[0,caml_call1(Base[109],lo$1),0]]],___],
         _aa_=
          [1,
           [0,
            caml_call1(Sexplib0_Sexp_conv[7],cst_float_bounds_are_crossed),
            _$_]];
        caml_call1(Base[207],_aa_)}
      var lo=lo$1,hi=hi$0;
      for(;;)
       {var range=caml_call2(Base[197],hi,lo);
        if(caml_call1(Base_Float[115],range))
         {var _S_=unit_float(state),_T_=caml_call2(Base[198],_S_,range);
          return caml_call2(Base[196],lo,_T_)}
        var _U_=caml_call2(Base[196],hi,lo),lo$0=caml_call2(Base[199],_U_,2.);
        if(bool(state)){var hi=lo$0;continue}
        var lo=lo$0;
        continue}}
    if(Ppx_bench_lib_Benchmark_accumulator[3])
     {var
       f=
        function(param)
         {return function(param){return unit_float_from_int64(int64$0)}};
      caml_call8
       (Ppx_bench_lib_Benchmark_accumulator[5],
        cst_unit_float_from_int64$0,
        cst_let_int64_1L_in_fun_unit_float_from_int64_int64,
        cst_src_splittable_random_ml$4,
        cst_src_splittable_random_ml$3,
        278,
        0,
        99,
        [0,f])}
    function Make(M)
     {function bits_to_represent(t)
       {if(caml_call2(M[11],t,M[42]))
         {var t$0=[0,t],n=[0,0];
          for(;;)
           {if(caml_call2(M[14],t$0[1],M[42]))
             {t$0[1] = caml_call2(M[77],t$0[1],1);
              caml_call1(Base_Int[79],n);
              continue}
            return n[1]}}
        throw [0,Assert_failure,_F_]}
      function _G_(param)
       {function test(n,expect)
         {var
           got=bits_to_represent(n),
           sexpifier=Base[115],
           comparator=Base[110];
          return caml_call8
                  (Ppx_assert_lib_Runtime[3],
                   pos$1,
                   sexpifier,
                   comparator,
                   0,
                   0,
                   0,
                   expect,
                   got)}
        test(caml_call1(M[3],0),0);
        test(caml_call1(M[3],1),1);
        test(caml_call1(M[3],2),2);
        test(caml_call1(M[3],3),2);
        test(caml_call1(M[3],4),3);
        test(caml_call1(M[3],5),3);
        test(caml_call1(M[3],6),3);
        test(caml_call1(M[3],7),3);
        test(caml_call1(M[3],8),4);
        test(caml_call1(M[3],100),7);
        var _R_=caml_call1(Base_Int[69],M[87]);
        return test(M[88],_R_)}
      caml_call8
       (Ppx_inline_test_lib_Runtime[5],
        Inline_test_config,
        cst_bits_to_represent,
        0,
        cst_src_splittable_random_ml$5,
        298,
        4,
        494,
        _G_);
      function min_represented_by_n_bits(n)
       {if(caml_call2(Base_Int[17],n,0))return M[42];
        var _Q_=caml_call1(Base_Int[69],n);
        return caml_call2(M[76],M[43],_Q_)}
      function _H_(param)
       {function test(n,expect)
         {var
           got=min_represented_by_n_bits(n),
           sexpifier=M[8],
           comparator=M[18];
          return caml_call8
                  (Ppx_assert_lib_Runtime[3],
                   pos$2,
                   sexpifier,
                   comparator,
                   0,
                   0,
                   0,
                   expect,
                   got)}
        test(0,caml_call1(M[3],0));
        test(1,caml_call1(M[3],1));
        test(2,caml_call1(M[3],2));
        test(3,caml_call1(M[3],4));
        test(4,caml_call1(M[3],8));
        test(7,caml_call1(M[3],64));
        var _P_=caml_call2(M[91],M[89],1);
        return test(caml_call1(Base_Int[69],M[87]),_P_)}
      caml_call8
       (Ppx_inline_test_lib_Runtime[5],
        Inline_test_config,
        cst_min_represented_by_n_bits,
        0,
        cst_src_splittable_random_ml$6,
        318,
        4,
        393,
        _H_);
      function max_represented_by_n_bits(n)
       {var _O_=caml_call2(M[76],M[43],n);return caml_call1(M[69],_O_)}
      function _I_(param)
       {function test(n,expect)
         {var
           got=max_represented_by_n_bits(n),
           sexpifier=M[8],
           comparator=M[18];
          return caml_call8
                  (Ppx_assert_lib_Runtime[3],
                   pos$3,
                   sexpifier,
                   comparator,
                   0,
                   0,
                   0,
                   expect,
                   got)}
        test(0,caml_call1(M[3],0));
        test(1,caml_call1(M[3],1));
        test(2,caml_call1(M[3],3));
        test(3,caml_call1(M[3],7));
        test(4,caml_call1(M[3],15));
        test(7,caml_call1(M[3],127));
        var _N_=M[88];
        return test(caml_call1(Base_Int[69],M[87]),_N_)}
      caml_call8
       (Ppx_inline_test_lib_Runtime[5],
        Inline_test_config,
        cst_max_represented_by_n_bits,
        0,
        cst_src_splittable_random_ml$7,
        332,
        4,
        369,
        _I_);
      function log_uniform(state,lo,hi)
       {var
         min_bits=bits_to_represent(lo),
         max_bits=bits_to_represent(hi),
         bits=int$0(state,min_bits,max_bits),
         _J_=max_represented_by_n_bits(bits),
         _K_=caml_call2(M[19],hi,_J_),
         _L_=min_represented_by_n_bits(bits),
         _M_=caml_call2(M[20],lo,_L_);
        return caml_call3(M[98],state,_M_,_K_)}
      return [0,log_uniform]}
    var
     of_float=Base_Int[1],
     to_float=Base_Int[2],
     of_int_exn=Base_Int[3],
     to_int_exn=Base_Int[4],
     hash_fold_t=Base_Int[5],
     hash=Base_Int[6],
     t_of_sexp=Base_Int[7],
     sexp_of_t=Base_Int[8],
     of_string=Base_Int[9],
     to_string=Base_Int[10],
     symbol=Base_Int[11],
     symbol$0=Base_Int[12],
     symbol$1=Base_Int[13],
     symbol$2=Base_Int[14],
     symbol$3=Base_Int[15],
     symbol$4=Base_Int[16],
     equal=Base_Int[17],
     compare=Base_Int[18],
     min=Base_Int[19],
     max=Base_Int[20],
     ascending=Base_Int[21],
     descending=Base_Int[22],
     between=Base_Int[23],
     clamp_exn=Base_Int[24],
     clamp=Base_Int[25],
     comparator=Base_Int[26],
     validate_lbound=Base_Int[27],
     validate_ubound=Base_Int[28],
     validate_bound=Base_Int[29],
     pp=Base_Int[30],
     validate_positive=Base_Int[31],
     validate_non_negative=Base_Int[32],
     validate_negative=Base_Int[33],
     validate_non_positive=Base_Int[34],
     is_positive=Base_Int[35],
     is_non_negative=Base_Int[36],
     is_negative=Base_Int[37],
     is_non_positive=Base_Int[38],
     sign=Base_Int[39],
     Hex=Base_Int[40],
     to_string_hum=Base_Int[41],
     zero=Base_Int[42],
     one=Base_Int[43],
     minus_one=Base_Int[44],
     symbol$5=Base_Int[45],
     symbol$6=Base_Int[46],
     symbol$7=Base_Int[47],
     symbol$8=Base_Int[48],
     neg=Base_Int[49],
     symbol$9=Base_Int[50],
     symbol$10=Base_Int[51],
     symbol$11=Base_Int[52],
     symbol$12=Base_Int[53],
     rem=Base_Int[54],
     symbol$13=Base_Int[55],
     land=Base_Int[56],
     lor=Base_Int[57],
     lxor=Base_Int[58],
     lnot=Base_Int[59],
     lsl=Base_Int[60],
     asr=Base_Int[61],
     round=Base_Int[62],
     round_towards_zero=Base_Int[63],
     round_down=Base_Int[64],
     round_up=Base_Int[65],
     round_nearest=Base_Int[66],
     abs=Base_Int[67],
     succ=Base_Int[68],
     pred=Base_Int[69],
     pow=Base_Int[70],
     bit_and=Base_Int[71],
     bit_or=Base_Int[72],
     bit_xor=Base_Int[73],
     bit_not=Base_Int[74],
     popcount=Base_Int[75],
     shift_left=Base_Int[76],
     shift_right=Base_Int[77],
     decr=Base_Int[78],
     incr=Base_Int[79],
     of_int32_exn=Base_Int[80],
     to_int32_exn=Base_Int[81],
     of_int64_exn=Base_Int[82],
     to_int64=Base_Int[83],
     of_nativeint_exn=Base_Int[84],
     to_nativeint_exn=Base_Int[85],
     of_float_unchecked=Base_Int[86],
     num_bits=Base_Int[87],
     max_value=Base_Int[88],
     min_value=Base_Int[89],
     lsr=Base_Int[90],
     shift_right_logical=Base_Int[91],
     ceil_pow2=Base_Int[92],
     floor_pow2=Base_Int[93],
     ceil_log2=Base_Int[94],
     floor_log2=Base_Int[95],
     is_pow2=Base_Int[96],
     O=Base_Int[97],
     For_int=
      Make
       ([0,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         validate_lbound,
         validate_ubound,
         validate_bound,
         pp,
         validate_positive,
         validate_non_negative,
         validate_negative,
         validate_non_positive,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         neg,
         symbol$9,
         symbol$10,
         symbol$11,
         symbol$12,
         rem,
         symbol$13,
         land,
         lor,
         lxor,
         lnot,
         lsl,
         asr,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         lsr,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         O,
         int$0]),
     of_float$0=Base_Int32[1],
     to_float$0=Base_Int32[2],
     of_int_exn$0=Base_Int32[3],
     to_int_exn$0=Base_Int32[4],
     hash_fold_t$0=Base_Int32[5],
     hash$0=Base_Int32[6],
     t_of_sexp$0=Base_Int32[7],
     sexp_of_t$0=Base_Int32[8],
     of_string$0=Base_Int32[9],
     to_string$0=Base_Int32[10],
     symbol$14=Base_Int32[11],
     symbol$15=Base_Int32[12],
     symbol$16=Base_Int32[13],
     symbol$17=Base_Int32[14],
     symbol$18=Base_Int32[15],
     symbol$19=Base_Int32[16],
     equal$0=Base_Int32[17],
     compare$0=Base_Int32[18],
     min$0=Base_Int32[19],
     max$0=Base_Int32[20],
     ascending$0=Base_Int32[21],
     descending$0=Base_Int32[22],
     between$0=Base_Int32[23],
     clamp_exn$0=Base_Int32[24],
     clamp$0=Base_Int32[25],
     comparator$0=Base_Int32[26],
     validate_lbound$0=Base_Int32[27],
     validate_ubound$0=Base_Int32[28],
     validate_bound$0=Base_Int32[29],
     pp$0=Base_Int32[30],
     validate_positive$0=Base_Int32[31],
     validate_non_negative$0=Base_Int32[32],
     validate_negative$0=Base_Int32[33],
     validate_non_positive$0=Base_Int32[34],
     is_positive$0=Base_Int32[35],
     is_non_negative$0=Base_Int32[36],
     is_negative$0=Base_Int32[37],
     is_non_positive$0=Base_Int32[38],
     sign$0=Base_Int32[39],
     Hex$0=Base_Int32[40],
     to_string_hum$0=Base_Int32[41],
     zero$0=Base_Int32[42],
     one$0=Base_Int32[43],
     minus_one$0=Base_Int32[44],
     symbol$20=Base_Int32[45],
     symbol$21=Base_Int32[46],
     symbol$22=Base_Int32[47],
     symbol$23=Base_Int32[48],
     neg$0=Base_Int32[49],
     symbol$24=Base_Int32[50],
     symbol$25=Base_Int32[51],
     symbol$26=Base_Int32[52],
     symbol$27=Base_Int32[53],
     rem$0=Base_Int32[54],
     symbol$28=Base_Int32[55],
     land$0=Base_Int32[56],
     lor$0=Base_Int32[57],
     lxor$0=Base_Int32[58],
     lnot$0=Base_Int32[59],
     lsl$0=Base_Int32[60],
     asr$0=Base_Int32[61],
     round$0=Base_Int32[62],
     round_towards_zero$0=Base_Int32[63],
     round_down$0=Base_Int32[64],
     round_up$0=Base_Int32[65],
     round_nearest$0=Base_Int32[66],
     abs$0=Base_Int32[67],
     succ$0=Base_Int32[68],
     pred$0=Base_Int32[69],
     pow$0=Base_Int32[70],
     bit_and$0=Base_Int32[71],
     bit_or$0=Base_Int32[72],
     bit_xor$0=Base_Int32[73],
     bit_not$0=Base_Int32[74],
     popcount$0=Base_Int32[75],
     shift_left$0=Base_Int32[76],
     shift_right$0=Base_Int32[77],
     decr$0=Base_Int32[78],
     incr$0=Base_Int32[79],
     of_int32_exn$0=Base_Int32[80],
     to_int32_exn$0=Base_Int32[81],
     of_int64_exn$0=Base_Int32[82],
     to_int64$0=Base_Int32[83],
     of_nativeint_exn$0=Base_Int32[84],
     to_nativeint_exn$0=Base_Int32[85],
     of_float_unchecked$0=Base_Int32[86],
     num_bits$0=Base_Int32[87],
     max_value$0=Base_Int32[88],
     min_value$0=Base_Int32[89],
     lsr$0=Base_Int32[90],
     shift_right_logical$0=Base_Int32[91],
     ceil_pow2$0=Base_Int32[92],
     floor_pow2$0=Base_Int32[93],
     ceil_log2$0=Base_Int32[94],
     floor_log2$0=Base_Int32[95],
     is_pow2$0=Base_Int32[96],
     O$0=Base_Int32[97],
     For_int32=
      Make
       ([0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$14,
         symbol$15,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         validate_lbound$0,
         validate_ubound$0,
         validate_bound$0,
         pp$0,
         validate_positive$0,
         validate_non_negative$0,
         validate_negative$0,
         validate_non_positive$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$20,
         symbol$21,
         symbol$22,
         symbol$23,
         neg$0,
         symbol$24,
         symbol$25,
         symbol$26,
         symbol$27,
         rem$0,
         symbol$28,
         land$0,
         lor$0,
         lxor$0,
         lnot$0,
         lsl$0,
         asr$0,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr$0,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         O$0,
         int32]),
     of_float$1=Base_Int63[1],
     to_float$1=Base_Int63[2],
     of_int_exn$1=Base_Int63[3],
     to_int_exn$1=Base_Int63[4],
     hash_fold_t$1=Base_Int63[5],
     hash$1=Base_Int63[6],
     t_of_sexp$1=Base_Int63[7],
     sexp_of_t$1=Base_Int63[8],
     of_string$1=Base_Int63[9],
     to_string$1=Base_Int63[10],
     symbol$29=Base_Int63[11],
     symbol$30=Base_Int63[12],
     symbol$31=Base_Int63[13],
     symbol$32=Base_Int63[14],
     symbol$33=Base_Int63[15],
     symbol$34=Base_Int63[16],
     equal$1=Base_Int63[17],
     compare$1=Base_Int63[18],
     min$1=Base_Int63[19],
     max$1=Base_Int63[20],
     ascending$1=Base_Int63[21],
     descending$1=Base_Int63[22],
     between$1=Base_Int63[23],
     clamp_exn$1=Base_Int63[24],
     clamp$1=Base_Int63[25],
     comparator$1=Base_Int63[26],
     validate_lbound$1=Base_Int63[27],
     validate_ubound$1=Base_Int63[28],
     validate_bound$1=Base_Int63[29],
     pp$1=Base_Int63[30],
     validate_positive$1=Base_Int63[31],
     validate_non_negative$1=Base_Int63[32],
     validate_negative$1=Base_Int63[33],
     validate_non_positive$1=Base_Int63[34],
     is_positive$1=Base_Int63[35],
     is_non_negative$1=Base_Int63[36],
     is_negative$1=Base_Int63[37],
     is_non_positive$1=Base_Int63[38],
     sign$1=Base_Int63[39],
     Hex$1=Base_Int63[40],
     to_string_hum$1=Base_Int63[41],
     zero$1=Base_Int63[42],
     one$1=Base_Int63[43],
     minus_one$1=Base_Int63[44],
     symbol$35=Base_Int63[45],
     symbol$36=Base_Int63[46],
     symbol$37=Base_Int63[47],
     symbol$38=Base_Int63[48],
     neg$1=Base_Int63[49],
     symbol$39=Base_Int63[50],
     symbol$40=Base_Int63[51],
     symbol$41=Base_Int63[52],
     symbol$42=Base_Int63[53],
     rem$1=Base_Int63[54],
     symbol$43=Base_Int63[55],
     land$1=Base_Int63[56],
     lor$1=Base_Int63[57],
     lxor$1=Base_Int63[58],
     lnot$1=Base_Int63[59],
     lsl$1=Base_Int63[60],
     asr$1=Base_Int63[61],
     round$1=Base_Int63[62],
     round_towards_zero$1=Base_Int63[63],
     round_down$1=Base_Int63[64],
     round_up$1=Base_Int63[65],
     round_nearest$1=Base_Int63[66],
     abs$1=Base_Int63[67],
     succ$1=Base_Int63[68],
     pred$1=Base_Int63[69],
     pow$1=Base_Int63[70],
     bit_and$1=Base_Int63[71],
     bit_or$1=Base_Int63[72],
     bit_xor$1=Base_Int63[73],
     bit_not$1=Base_Int63[74],
     popcount$1=Base_Int63[75],
     shift_left$1=Base_Int63[76],
     shift_right$1=Base_Int63[77],
     decr$1=Base_Int63[78],
     incr$1=Base_Int63[79],
     of_int32_exn$1=Base_Int63[80],
     to_int32_exn$1=Base_Int63[81],
     of_int64_exn$1=Base_Int63[82],
     to_int64$1=Base_Int63[83],
     of_nativeint_exn$1=Base_Int63[84],
     to_nativeint_exn$1=Base_Int63[85],
     of_float_unchecked$1=Base_Int63[86],
     num_bits$1=Base_Int63[87],
     max_value$1=Base_Int63[88],
     min_value$1=Base_Int63[89],
     lsr$1=Base_Int63[90],
     shift_right_logical$1=Base_Int63[91],
     ceil_pow2$1=Base_Int63[92],
     floor_pow2$1=Base_Int63[93],
     ceil_log2$1=Base_Int63[94],
     is_pow2$1=Base_Int63[95],
     O$1=Base_Int63[96],
     floor_log2$1=Base_Int63[112],
     For_int63=
      Make
       ([0,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$29,
         symbol$30,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         validate_lbound$1,
         validate_ubound$1,
         validate_bound$1,
         pp$1,
         validate_positive$1,
         validate_non_negative$1,
         validate_negative$1,
         validate_non_positive$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$35,
         symbol$36,
         symbol$37,
         symbol$38,
         neg$1,
         symbol$39,
         symbol$40,
         symbol$41,
         symbol$42,
         rem$1,
         symbol$43,
         land$1,
         lor$1,
         lxor$1,
         lnot$1,
         lsl$1,
         asr$1,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$1,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         O$1,
         int63]),
     of_float$2=Base_Int64[1],
     to_float$2=Base_Int64[2],
     of_int_exn$2=Base_Int64[3],
     to_int_exn$2=Base_Int64[4],
     hash_fold_t$2=Base_Int64[5],
     hash$2=Base_Int64[6],
     t_of_sexp$2=Base_Int64[7],
     sexp_of_t$2=Base_Int64[8],
     of_string$2=Base_Int64[9],
     to_string$2=Base_Int64[10],
     symbol$44=Base_Int64[11],
     symbol$45=Base_Int64[12],
     symbol$46=Base_Int64[13],
     symbol$47=Base_Int64[14],
     symbol$48=Base_Int64[15],
     symbol$49=Base_Int64[16],
     equal$2=Base_Int64[17],
     compare$2=Base_Int64[18],
     min$2=Base_Int64[19],
     max$2=Base_Int64[20],
     ascending$2=Base_Int64[21],
     descending$2=Base_Int64[22],
     between$2=Base_Int64[23],
     clamp_exn$2=Base_Int64[24],
     clamp$2=Base_Int64[25],
     comparator$2=Base_Int64[26],
     validate_lbound$2=Base_Int64[27],
     validate_ubound$2=Base_Int64[28],
     validate_bound$2=Base_Int64[29],
     pp$2=Base_Int64[30],
     validate_positive$2=Base_Int64[31],
     validate_non_negative$2=Base_Int64[32],
     validate_negative$2=Base_Int64[33],
     validate_non_positive$2=Base_Int64[34],
     is_positive$2=Base_Int64[35],
     is_non_negative$2=Base_Int64[36],
     is_negative$2=Base_Int64[37],
     is_non_positive$2=Base_Int64[38],
     sign$2=Base_Int64[39],
     Hex$2=Base_Int64[40],
     to_string_hum$2=Base_Int64[41],
     zero$2=Base_Int64[42],
     one$2=Base_Int64[43],
     minus_one$2=Base_Int64[44],
     symbol$50=Base_Int64[45],
     symbol$51=Base_Int64[46],
     symbol$52=Base_Int64[47],
     symbol$53=Base_Int64[48],
     neg$2=Base_Int64[49],
     symbol$54=Base_Int64[50],
     symbol$55=Base_Int64[51],
     symbol$56=Base_Int64[52],
     symbol$57=Base_Int64[53],
     rem$2=Base_Int64[54],
     symbol$58=Base_Int64[55],
     land$2=Base_Int64[56],
     lor$2=Base_Int64[57],
     lxor$2=Base_Int64[58],
     lnot$2=Base_Int64[59],
     lsl$2=Base_Int64[60],
     asr$2=Base_Int64[61],
     round$2=Base_Int64[62],
     round_towards_zero$2=Base_Int64[63],
     round_down$2=Base_Int64[64],
     round_up$2=Base_Int64[65],
     round_nearest$2=Base_Int64[66],
     abs$2=Base_Int64[67],
     succ$2=Base_Int64[68],
     pred$2=Base_Int64[69],
     pow$2=Base_Int64[70],
     bit_and$2=Base_Int64[71],
     bit_or$2=Base_Int64[72],
     bit_xor$2=Base_Int64[73],
     bit_not$2=Base_Int64[74],
     popcount$2=Base_Int64[75],
     shift_left$2=Base_Int64[76],
     shift_right$2=Base_Int64[77],
     decr$2=Base_Int64[78],
     incr$2=Base_Int64[79],
     of_int32_exn$2=Base_Int64[80],
     to_int32_exn$2=Base_Int64[81],
     of_int64_exn$2=Base_Int64[82],
     to_int64$2=Base_Int64[83],
     of_nativeint_exn$2=Base_Int64[84],
     to_nativeint_exn$2=Base_Int64[85],
     of_float_unchecked$2=Base_Int64[86],
     num_bits$2=Base_Int64[87],
     max_value$2=Base_Int64[88],
     min_value$2=Base_Int64[89],
     lsr$2=Base_Int64[90],
     shift_right_logical$2=Base_Int64[91],
     ceil_pow2$2=Base_Int64[92],
     floor_pow2$2=Base_Int64[93],
     ceil_log2$2=Base_Int64[94],
     floor_log2$2=Base_Int64[95],
     is_pow2$2=Base_Int64[96],
     O$2=Base_Int64[97],
     For_int64=
      Make
       ([0,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         symbol$44,
         symbol$45,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         validate_lbound$2,
         validate_ubound$2,
         validate_bound$2,
         pp$2,
         validate_positive$2,
         validate_non_negative$2,
         validate_negative$2,
         validate_non_positive$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         neg$2,
         symbol$54,
         symbol$55,
         symbol$56,
         symbol$57,
         rem$2,
         symbol$58,
         land$2,
         lor$2,
         lxor$2,
         lnot$2,
         lsl$2,
         asr$2,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         lsr$2,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         O$2,
         int64]),
     of_float$3=Base_Nativeint[1],
     to_float$3=Base_Nativeint[2],
     of_int_exn$3=Base_Nativeint[3],
     to_int_exn$3=Base_Nativeint[4],
     hash_fold_t$3=Base_Nativeint[5],
     hash$3=Base_Nativeint[6],
     t_of_sexp$3=Base_Nativeint[7],
     sexp_of_t$3=Base_Nativeint[8],
     of_string$3=Base_Nativeint[9],
     to_string$3=Base_Nativeint[10],
     symbol$59=Base_Nativeint[11],
     symbol$60=Base_Nativeint[12],
     symbol$61=Base_Nativeint[13],
     symbol$62=Base_Nativeint[14],
     symbol$63=Base_Nativeint[15],
     symbol$64=Base_Nativeint[16],
     equal$3=Base_Nativeint[17],
     compare$3=Base_Nativeint[18],
     min$3=Base_Nativeint[19],
     max$3=Base_Nativeint[20],
     ascending$3=Base_Nativeint[21],
     descending$3=Base_Nativeint[22],
     between$3=Base_Nativeint[23],
     clamp_exn$3=Base_Nativeint[24],
     clamp$3=Base_Nativeint[25],
     comparator$3=Base_Nativeint[26],
     validate_lbound$3=Base_Nativeint[27],
     validate_ubound$3=Base_Nativeint[28],
     validate_bound$3=Base_Nativeint[29],
     pp$3=Base_Nativeint[30],
     validate_positive$3=Base_Nativeint[31],
     validate_non_negative$3=Base_Nativeint[32],
     validate_negative$3=Base_Nativeint[33],
     validate_non_positive$3=Base_Nativeint[34],
     is_positive$3=Base_Nativeint[35],
     is_non_negative$3=Base_Nativeint[36],
     is_negative$3=Base_Nativeint[37],
     is_non_positive$3=Base_Nativeint[38],
     sign$3=Base_Nativeint[39],
     Hex$3=Base_Nativeint[40],
     to_string_hum$3=Base_Nativeint[41],
     zero$3=Base_Nativeint[42],
     one$3=Base_Nativeint[43],
     minus_one$3=Base_Nativeint[44],
     symbol$65=Base_Nativeint[45],
     symbol$66=Base_Nativeint[46],
     symbol$67=Base_Nativeint[47],
     symbol$68=Base_Nativeint[48],
     neg$3=Base_Nativeint[49],
     symbol$69=Base_Nativeint[50],
     symbol$70=Base_Nativeint[51],
     symbol$71=Base_Nativeint[52],
     symbol$72=Base_Nativeint[53],
     rem$3=Base_Nativeint[54],
     symbol$73=Base_Nativeint[55],
     land$3=Base_Nativeint[56],
     lor$3=Base_Nativeint[57],
     lxor$3=Base_Nativeint[58],
     lnot$3=Base_Nativeint[59],
     lsl$3=Base_Nativeint[60],
     asr$3=Base_Nativeint[61],
     round$3=Base_Nativeint[62],
     round_towards_zero$3=Base_Nativeint[63],
     round_down$3=Base_Nativeint[64],
     round_up$3=Base_Nativeint[65],
     round_nearest$3=Base_Nativeint[66],
     abs$3=Base_Nativeint[67],
     succ$3=Base_Nativeint[68],
     pred$3=Base_Nativeint[69],
     pow$3=Base_Nativeint[70],
     bit_and$3=Base_Nativeint[71],
     bit_or$3=Base_Nativeint[72],
     bit_xor$3=Base_Nativeint[73],
     bit_not$3=Base_Nativeint[74],
     popcount$3=Base_Nativeint[75],
     shift_left$3=Base_Nativeint[76],
     shift_right$3=Base_Nativeint[77],
     decr$3=Base_Nativeint[78],
     incr$3=Base_Nativeint[79],
     of_int32_exn$3=Base_Nativeint[80],
     to_int32_exn$3=Base_Nativeint[81],
     of_int64_exn$3=Base_Nativeint[82],
     to_int64$3=Base_Nativeint[83],
     of_nativeint_exn$3=Base_Nativeint[84],
     to_nativeint_exn$3=Base_Nativeint[85],
     of_float_unchecked$3=Base_Nativeint[86],
     num_bits$3=Base_Nativeint[87],
     max_value$3=Base_Nativeint[88],
     min_value$3=Base_Nativeint[89],
     lsr$3=Base_Nativeint[90],
     shift_right_logical$3=Base_Nativeint[91],
     ceil_pow2$3=Base_Nativeint[92],
     floor_pow2$3=Base_Nativeint[93],
     ceil_log2$3=Base_Nativeint[94],
     floor_log2$3=Base_Nativeint[95],
     is_pow2$3=Base_Nativeint[96],
     O$3=Base_Nativeint[97],
     For_nativeint=
      Make
       ([0,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$59,
         symbol$60,
         symbol$61,
         symbol$62,
         symbol$63,
         symbol$64,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         validate_lbound$3,
         validate_ubound$3,
         validate_bound$3,
         pp$3,
         validate_positive$3,
         validate_non_negative$3,
         validate_negative$3,
         validate_non_positive$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$65,
         symbol$66,
         symbol$67,
         symbol$68,
         neg$3,
         symbol$69,
         symbol$70,
         symbol$71,
         symbol$72,
         rem$3,
         symbol$73,
         land$3,
         lor$3,
         lxor$3,
         lnot$3,
         lsl$3,
         asr$3,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$3,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         O$3,
         nativeint]),
     int$1=For_int[1],
     int32$0=For_int32[1],
     int63$0=For_int63[1],
     int64$1=For_int64[1],
     nativeint$0=For_nativeint[1];
    caml_call1(Ppx_inline_test_lib_Runtime[3],cst_splittable_random$1);
    caml_call1(Ppx_bench_lib_Benchmark_accumulator[1][2],0);
    var
     Splittable_random=
      [0,
       [0,create,of_int,perturb,copy,split],
       bool,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       unit_float,
       [0,int$1,int32$0,int63$0,int64$1,nativeint$0]];
    runtime.caml_register_global(94,Splittable_random,"Splittable_random");
    return}
  (function(){return this}()));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzcGxpdHRhYmxlX3JhbmRvbS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7SSIsInNvdXJjZXMiOltdLCJzb3VyY2VzQ29udGVudCI6W119
